package com.reintroducing.ui{	import fl.transitions.Tween;	import fl.transitions.easing.*;		import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Stage;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;		/**	 * Creates a scroller that allows for scrolling in the x or y axis, using the mouse wheel/arrow keys, different easing functions and types, and some other miscellaneous cool things.	 * 	 * @author Matt Przybylski [http://www.reintroducing.com]	 * @version 1.1	 */	public class AxisScroller 	{//- PRIVATE & PROTECTED VARIABLES -------------------------------------------------------------------------		private var _stage:Stage;		private var _changeProp:String;		private var _mouseAxis:String;		private var _changeScale:String;		private var _nextPosition:int;		private var _arrowMove:Number;		private var _scaleScroller:Boolean;		private var _autoHideControls:Boolean;		private var _mouseIsPressedDown:Boolean;		private var _trackStart:Number;		private var _trackEnd:Number;		private var _tween:Tween;		private var _arrow1Tween:Tween;		private var _arrow2Tween:Tween;		private var _scrollerTween:Tween;		private var _trackTween:Tween;		private var _easeFunc:Function;		private var _duration:Number;		private var _axis:String;		private var _scrollType:String;		private var _isTrackClickable:Boolean;		private var _arrows:Boolean;		private var _upArrow:MovieClip;		private var _downArrow:MovieClip;		private var _continuousScroll:Boolean;		private var _arrowTimer:Timer;		private var _arrowPressed:String;		private var _contentSize:Number;		private var _timeToHideControls:Number;				protected var _holder:*;		protected var _scroller:*;		protected var _toBeScrolled:*;		protected var _track:*;		protected var _mask:*;		//- PUBLIC & INTERNAL VARIABLES ---------------------------------------------------------------------------				public static const DEFAULT_NAME:String = "com.reintroducing.ui.AxisScroller";		//- CONSTRUCTOR	-------------------------------------------------------------------------------------------			/**		 * Creates a new instance of the AxisScroller class.		 * 		 * <p>		 * The $optionalParams parameter takes in a couple of values.		 * <ul>		 * <li>scrollType: A string representing the scroll type, "instant" or "easing" (default: "easing")</li>		 * <li>isTrackClickable: A boolean value that makes the track clickable so that you can scroll directly to a certain spot (default: true)</li>		 * <li>useArrows: A boolean value that allows the use of arrow buttons (default: false)</li>		 * <li>upArrow: If useArrows, a movie clip that represents the up arrow button (default: null)</li>		 * <li>downArrow: If useArrows, a movie clip that represents the down arrow button (default: null)</li>		 * <li>continuousScroll: If useArrows, a boolean that specifies if when pressing the arrows the scrolling should happen continuously or not (default: false)</li>		 * <li>easeFunc: A function representing the ease type you'd like to use, as per the Tween class easing functions (default: Regular.easeOut)</li>		 * <li>duration: An number (in seconds) representing the time that the scrollable content will take to move when easing is used (default: .25)</li>		 * <li>arrowMove: An number (in pixels) that the scrollable content will move onMouseWheel/Key/Arrow movement (default: 100)</li>		 * <li>autoHideControls: A boolean value that hides the scroller/track/arrows (if applicable) if the scroll content is too small to scroll (default: false)</li>		 * <li>timeToHideControls: A number (in seconds) representing the time that it takes to hide the controls if autoHideControls is active (default: .25)</li>		 * <li>scaleScroller *: A boolean value that allows automatic scaling of the scroll bar (default: false)</li>		 * </ul>		 * * If you use the scaleScroller optional parameter, please make the size of the scroll bar the same size as the track and this will take care of		 * scaling it automatically for you.  If you AREN'T using this parameter, please size your scroll bar accordingly manually. 		 * </p>		 *		 * @param $stage The stage object to use for keyboard input		 * @param $holder The object that holds all of the other clips corresponding to the scroller		 * @param $scroller The object to be used as the scroller		 * @param $toBeScrolled The object where the scrollable content resides		 * @param $track The object that is used as the track (measures extremes)		 * @param $mask The object that is used as the mask for the scrollable content area		 * @param $axis A string value of either "x" or "y" that determines what axis the content is scrolled along		 * @param $optionalParams Optional parameters to further control the scroller		 * 		 * @return void		 */		public function AxisScroller($stage:Stage, $holder:*, $scroller:*, $toBeScrolled:*, $track:*, $mask:*, $axis:String, $optionalParams:Object):void		{			this._stage						= $stage;			this._holder 					= $holder;			this._scroller 					= $scroller;			this._toBeScrolled 				= $toBeScrolled;			this._track 					= $track;			this._mask 						= $mask;			this._axis 						= $axis;						this._scrollType 				= ($optionalParams.scrollType == null) ? "easing" : $optionalParams.scrollType;			this._isTrackClickable 			= ($optionalParams.isTrackClickable == null) ? true : $optionalParams.isTrackClickable;			this._arrows 					= ($optionalParams.useArrows == null) ? false : $optionalParams.useArrows;			this._upArrow 					= ($optionalParams.upArrow == null) ? null : $optionalParams.upArrow;			this._downArrow 				= ($optionalParams.downArrow == null) ? null : $optionalParams.downArrow;			this._continuousScroll			= ($optionalParams.continuousScroll == null) ? false : $optionalParams.continuousScroll;			this._easeFunc 					= ($optionalParams.easeFunc == null) ? Regular.easeOut : $optionalParams.easeFunc;			this._duration 					= ($optionalParams.duration == null) ? .25 : $optionalParams.duration;			this._arrowMove 				= ($optionalParams.arrowMove == null) ? 100 : $optionalParams.arrowMove;			this._autoHideControls			= ($optionalParams.autoHideControls == null) ? false : $optionalParams.autoHideControls;			this._timeToHideControls		= ($optionalParams.timeToHideControls == null) ? .25 : $optionalParams.autoHideControls;			this._scaleScroller				= ($optionalParams.scaleScroller == null) ? false : $optionalParams.scaleScroller;						this.manageAxis(this._axis);			this.init();		}		//- PRIVATE & PROTECTED METHODS ---------------------------------------------------------------------------				// initiates listeners and other events		private function init():void		{			this._holder.addEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel);			this._holder.addEventListener(Event.ENTER_FRAME, manageScrolling);			this._stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);						if (this._continuousScroll)			{				this._arrowTimer = new Timer(80);				this._arrowTimer.addEventListener(TimerEvent.TIMER, manageContinuousScroll);			}						this.activateButtonEvents();		}				// re-activates the button events		protected function activateButtonEvents():void		{			this._scroller.addEventListener(MouseEvent.MOUSE_DOWN, manageMouseDown);			this._scroller.buttonMode = true;						if (this._isTrackClickable) 			{				this._track.addEventListener(MouseEvent.MOUSE_UP, manageTrack);				this._track.buttonMode = true;			}						if (this._arrows)			{				this._upArrow.addEventListener(MouseEvent.MOUSE_DOWN, manageUpArrow);				this._upArrow.addEventListener(MouseEvent.MOUSE_UP, resetArrowTimer);								this._downArrow.addEventListener(MouseEvent.MOUSE_DOWN, manageDownArrow);				this._downArrow.addEventListener(MouseEvent.MOUSE_UP, resetArrowTimer);								this._downArrow.buttonMode = this._upArrow.buttonMode = true;			}		}				// destroys the events on the buttons		protected function killButtonEvents():void		{			this._scroller.removeEventListener(MouseEvent.MOUSE_DOWN, manageMouseDown);			this._scroller.buttonMode = false;						if (this._isTrackClickable) 			{				this._track.removeEventListener(MouseEvent.MOUSE_UP, manageTrack);				this._track.buttonMode = false;			}						if (this._arrows)			{				this._upArrow.removeEventListener(MouseEvent.MOUSE_UP, manageUpArrow);				this._upArrow.removeEventListener(MouseEvent.MOUSE_DOWN, manageUpArrow);								this._downArrow.removeEventListener(MouseEvent.MOUSE_UP, manageDownArrow);				this._downArrow.removeEventListener(MouseEvent.MOUSE_DOWN, manageDownArrow);								this._downArrow.buttonMode = this._upArrow.buttonMode = false;			}		}				// sets the axis at which the scroller will function against		private function manageAxis($axis:String):void		{			if ($axis == "x") 			{				this._changeProp 			= "width";				this._mouseAxis 			= "mouseX";				this._changeScale			= "scaleX";			} 			else if ($axis == "y") 			{				this._changeProp 			= "height";				this._mouseAxis 			= "mouseY";				this._changeScale			= "scaleY";			}						this._contentSize = this._toBeScrolled[this._changeProp];						if (this._contentSize <= this._mask[this._changeProp] && this._autoHideControls) this.manageControls();		}				// calculates values and responds to changes by the scroller		private function manageScrolling($evt:Event):void		{			var trackSize:Number 			= this._track[this._changeProp];			var trackStart:Number 			= this._track[this._axis];			var trackEnd:Number 			= this._track[this._axis] + trackSize - (this._scroller[this._changeProp]);			var trackRange:Number 			= trackEnd - trackStart;			var maskSize:Number 			= this._mask[this._changeProp];			var movieSize:Number 			= this._toBeScrolled[this._changeProp];			var minPosition:Number 			= this._mask[this._axis] + 2;			var maxPosition:Number 			= minPosition + movieSize - maskSize + 4;			var onePercentChange:Number 	= (maxPosition - minPosition) / 100;			var percent:int 				= Math.round(((this._scroller[this._axis] - trackStart) / trackRange) * 100);			var targetPosition:int	 		= Math.round(minPosition - (onePercentChange * percent));						this._trackStart 				= trackStart;			this._trackEnd 					= trackEnd;						if (this._scrollType == "instant") 			{				this._toBeScrolled[this._axis] = targetPosition;			} 			else if (this._scrollType == "easing") 			{				this._toBeScrolled[this._axis] += Math.round((targetPosition - this._toBeScrolled[this._axis]) / 5);			}				if (movieSize < maskSize) 			{				onePercentChange = 0;			}						if (this._mouseIsPressedDown) 			{				this._scroller[this._axis] = Math.round(this._holder[this._mouseAxis] - (this._scroller[this._changeProp] / 2));			}						// put scroller at right position if bounds are hit			if (this._scroller[this._axis] < trackStart) 			{				this._scroller[this._axis] = Math.round(trackStart);			} 			else if (this._scroller[this._axis] > trackEnd) 			{				this._scroller[this._axis] = Math.round(trackEnd);			}						// set the scroller in the proper spot if content size is changed on the fly			if (this._contentSize < this._mask[this._changeProp]) this._scroller[this._axis] = Math.round(this._trackStart);						// scale the scroller if its enabled			if (this._scaleScroller) this.manageScrollScaling(movieSize, maskSize);						// manage the hiding of controls if it is enabled			if (this._contentSize != movieSize  && this._autoHideControls)			{				this._contentSize = movieSize;				this.manageControls();			}		}				// regulates mouse pressed down		protected function manageMouseDown($evt:MouseEvent):void 		{			this._mouseIsPressedDown = true;						this._holder.stage.addEventListener(MouseEvent.MOUSE_UP, manageMouseUp);		}				// regulates mouse released and mouse released outside		protected function manageMouseUp($evt:MouseEvent):void 		{			this._mouseIsPressedDown = false;						this._holder.stage.removeEventListener(MouseEvent.MOUSE_UP, manageMouseUp);		}				// regulates the movement of the content based on where the track is clicked, if applicable		private function manageTrack($evt:MouseEvent):void 		{			if (this._isTrackClickable)			{				if (this._scrollType == "instant") 				{					if (this._holder[this._mouseAxis] < this._trackStart) 					{						this._scroller[this._axis] = this._trackStart;					} 					else if (this._holder[this._mouseAxis] > this._trackEnd) 					{						this._scroller[this._axis] = this._trackEnd;					} 					else 					{						this._scroller[this._axis] = Math.round(this._holder[this._mouseAxis] - (this._scroller[this._changeProp] / 2));					}				} 				else if (this._scrollType == "easing") 				{					if (this._holder[this._mouseAxis] < this._trackStart) 					{						this._tween = new Tween(this._scroller, this._axis, this._easeFunc, this._scroller[this._axis], this._trackStart, this._duration, true);					} 					else if (this._holder[this._mouseAxis] > this._trackEnd) 					{						this._tween = new Tween(this._scroller, this._axis, this._easeFunc, this._scroller[this._axis], this._trackEnd, this._duration, true);					} 					else 					{						this._tween = new Tween(this._scroller, this._axis, this._easeFunc, this._scroller[this._axis], Math.round(this._holder[this._mouseAxis] - (this._scroller[this._changeProp] / 2)), this._duration, true);					}				}			}		}				// moves the scroller up when the up arrow is clicked		private function moveUp():void		{			if (this._scrollType == "instant") 			{				this._nextPosition = Math.round(this._scroller[this._axis] - this._arrowMove);								if (this._nextPosition < this._trackStart) 				{					this._scroller[this._axis] = this._trackStart;				} 				else 				{					this._scroller[this._axis] = this._nextPosition;				}			} 			else if (this._scrollType == "easing") 			{				this._nextPosition = Math.round(this._scroller[this._axis] - this._arrowMove);								if (this._nextPosition < this._trackStart) 				{					this._tween = new Tween(this._scroller, this._axis, this._easeFunc, this._scroller[this._axis], this._trackStart, this._duration, true);				} 				else 				{					this._tween = new Tween(this._scroller, this._axis, this._easeFunc, this._scroller[this._axis], this._nextPosition, this._duration, true);				}			}		}				// moves the scroller down when the down arrow is clicked		private function moveDown():void		{			if (this._scrollType == "instant") 			{				this._nextPosition = Math.round(this._scroller[this._axis] + this._arrowMove);								if (this._nextPosition > this._trackEnd) 				{					this._scroller[this._axis] = this._trackEnd;				} 				else 				{					this._scroller[this._axis] = this._nextPosition;				}			} 			else if (this._scrollType == "easing") 			{				this._nextPosition = Math.round(this._scroller[this._axis] + this._arrowMove);								if (this._nextPosition > this._trackEnd) 				{					this._tween = new Tween(this._scroller, this._axis, this._easeFunc, this._scroller[this._axis], this._trackEnd, this._duration, true);				} 				else 				{					this._tween = new Tween(this._scroller, this._axis, this._easeFunc, this._scroller[this._axis], this._nextPosition, this._duration, true);				}			}		}				// regulates the movement of the up arrow, if applicable		private function manageUpArrow($evt:MouseEvent):void 		{			if (this._continuousScroll) 			{				this._arrowPressed = "up";				this._arrowTimer.start();			}			else			{				this.moveUp();			}		}				// regulates the movement of the down arrow, if applicable		private function manageDownArrow($evt:MouseEvent):void 		{			if (this._continuousScroll) 			{				this._arrowPressed = "down";				this._arrowTimer.start();			}			else			{				this.moveDown();			}		}				// if continuous scroll is on, manages the timer that moves it up and down		private function manageContinuousScroll($evt:TimerEvent):void		{			if (this._arrowPressed == "up")			{				this.moveUp();			}			else if (this._arrowPressed == "down")			{				this.moveDown();			}		}				// if continuous scroll is on, resets the timer after you release an arrow button		private function resetArrowTimer($evt:MouseEvent):void		{			if (this._continuousScroll) 			{				this._arrowTimer.reset();			}		}				// auto hides/shows the controls of the scroller		private function manageControls():void		{			if (this._toBeScrolled[this._changeProp] <= this._mask[this._changeProp])			{				// yes, hide controls				this._scrollerTween = new Tween(this._scroller, "alpha", None.easeNone, this._scroller.alpha, 0, this._timeToHideControls, true);				this._trackTween 	= new Tween(this._track, "alpha", None.easeNone, this._track.alpha, 0, this._timeToHideControls, true);								if (this._arrows)				{					this._arrow1Tween 	= new Tween(this._upArrow, "alpha", None.easeNone, this._upArrow.alpha, 0, this._timeToHideControls, true);					this._arrow2Tween 	= new Tween(this._downArrow, "alpha", None.easeNone, this._downArrow.alpha, 0, this._timeToHideControls, true);				}								this.killButtonEvents();			}			else			{				// no, show controls				this._scrollerTween = new Tween(this._scroller, "alpha", None.easeNone, this._scroller.alpha, 100, this._timeToHideControls, true);				this._trackTween 	= new Tween(this._track, "alpha", None.easeNone, this._track.alpha, 100, this._timeToHideControls, true);								if (this._arrows)				{					this._arrow1Tween 	= new Tween(this._upArrow, "alpha", None.easeNone, this._upArrow.alpha, 100, this._timeToHideControls, true);					this._arrow2Tween 	= new Tween(this._downArrow, "alpha", None.easeNone, this._downArrow.alpha, 100, this._timeToHideControls, true);				}								this.activateButtonEvents();			}		}				// regulates the scaling of the scroller, if applicable		private function manageScrollScaling($contentSize:Number, $maskSize:Number):void		{			var trackPercent:Number = ($maskSize / $contentSize);						if ($contentSize > $maskSize)			{				this._scroller[this._changeScale] = trackPercent;			}			else			{				this._scroller[this._changeScale] = 1;			}		}				// regulates the movement of the mouse wheel		private function onMouseWheel($evt:MouseEvent):void		{			var delta:int = $evt.delta;			var multiplier:Number = 10;						if (this._scrollType == "instant") 			{				this._nextPosition = Math.round(this._scroller[this._axis] - (delta * multiplier));								if (this._nextPosition < this._trackStart) 				{					this._scroller[this._axis] = this._trackStart;				} 				else if (this._nextPosition > this._trackEnd) 				{					this._scroller[this._axis] = this._trackEnd;				} 				else 				{					this._scroller[this._axis] = this._nextPosition;				}			} 			else if (this._scrollType == "easing") 			{				this._nextPosition = Math.round(this._scroller[this._axis] - (delta * multiplier));								if (this._nextPosition < this._trackStart) 				{					this._tween = new Tween(this._scroller, this._axis, this._easeFunc, this._scroller[this._axis], this._trackStart, this._duration, true);				} 				else if (this._nextPosition > this._trackEnd) 				{					this._tween = new Tween(this._scroller, this._axis, this._easeFunc, this._scroller[this._axis], this._trackEnd, this._duration, true);				} 				else 				{					this._tween = new Tween(this._scroller, this._axis, this._easeFunc, this._scroller[this._axis], this._nextPosition, this._duration, true);				}			}		}				// regulates the movement of the up and down keyboard keys		private function onKeyPressed($evt:KeyboardEvent):void		{			if (this._axis == "x")			{				switch($evt.keyCode) 				{					case 37: // left						this.moveUp();						break;											case 39: // right						this.moveDown();						break;				}			}			else if (this._axis == "y")			{				switch($evt.keyCode) 				{					case 38: // up						this.moveUp();						break;											case 40: // down						this.moveDown();						break;				}			}		}		//- PUBLIC & INTERNAL METHODS -----------------------------------------------------------------------------			/**		 * Creates the scroller again if it was deleted using destroy.		 * 		 * @return void		 */		public function create():void		{			this.init();		}				/**		 * Enables the scroller, track, and arrow buttons (if applicable).		 * 		 * @return void		 */		public function setEnabled():void		{			this.activateButtonEvents();		}				/**		 * Disables the scroller, track, and arrow buttons (if applicable).		 * 		 * @return void		 */		public function setDisabled():void		{			this.activateButtonEvents();		}				/**		 * Resets the position of the scroller and the content movie clip to its initial position.		 * 		 * @return void		 */		public function reset():void		{			this._scroller[this._axis] = this._trackStart;		}				/**		 * Performs garbage collection of events.		 * 		 * @return void		 */		public function destroy():void		{			this._holder.removeEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel);			this._holder.removeEventListener(Event.ENTER_FRAME, manageScrolling);			this._stage.removeEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);						if (this._continuousScroll)			{				this._arrowTimer.removeEventListener(TimerEvent.TIMER, manageContinuousScroll);				this._arrowTimer = null;			}						this.killButtonEvents();		}	//- EVENT HANDLERS ----------------------------------------------------------------------------------------				//- GETTERS & SETTERS -------------------------------------------------------------------------------------			/**		 * Gets the value of autoHideControls to see if they are currently being hidden or not.		 * 		 * @usage <pre><code>trace(scroller.autoHideControls);</code></pre>		 * 		 * @return Boolean		 */				public function get autoHideControls():Boolean		{			return this._autoHideControls;		}				/**		 * Sets the value of autoHideControls "on-the-fly".		 * 		 * @usage <pre><code>scroller.autoHideControls = true;</code></pre>		 * 		 * @return Nothing		 */				public function set autoHideControls($b:Boolean):void		{			this._autoHideControls = $b;		}	//- HELPERS -----------------------------------------------------------------------------------------------			public function toString():String		{			return "com.reintroducing.ui.AxisScroller";		}	//- END CLASS ---------------------------------------------------------------------------------------------	}}